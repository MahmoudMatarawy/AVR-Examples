/*
 * ADC.c
 *
 * Created: 4/11/2022 9:18:38 PM
 * Author: Mahmoud Sarhan
 * Email  : eng.mahmoud.adel94@gmail.com
 */ 


#include "ADC.h"

uint8_t ADC_STATUS = NOT_INIT; 
void ADC_INIT(ADC_CONFIG *param)
{
	ADC_DDR = 0x00;
	ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_ENABLE);
	switch(param->ref_selection)
	{
		case AVCC :
		ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(REF_SELCTION_BIT_0);
		break;
		
		case INTERNAL_2_56V_REF :
		ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(REF_SELCTION_BIT_0) | ENABLE(REF_SELCTION_BIT_1);
		break;
	}
	
	if(param->ADC_LEFT_ADJUST_RESULT_enable == INIT)
	{
		ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(ADC_LEFT_ADJUST_RESULT);
	}
	
	switch(param->prescaler_selection)
	{
		case PRESCALER_2 :
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_PRESCALER_SELECTION_BIT_0);
		break;
		
		case PRESCALER_4 :
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_PRESCALER_SELECTION_BIT_1);
		break;
		
		case PRESCALER_8 :
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_PRESCALER_SELECTION_BIT_0) | ENABLE(ADC_PRESCALER_SELECTION_BIT_1);
		break;
		
		case PRESCALER_16 :
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_PRESCALER_SELECTION_BIT_2);
		break;
		
		case PRESCALER_32 :
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_PRESCALER_SELECTION_BIT_0) | ENABLE(ADC_PRESCALER_SELECTION_BIT_2);
		break;
		
		case PRESCALER_64 :
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_PRESCALER_SELECTION_BIT_1) | ENABLE(ADC_PRESCALER_SELECTION_BIT_2);
		break;
		
		case PRESCALER_128 :
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_PRESCALER_SELECTION_BIT_0) | ENABLE(ADC_PRESCALER_SELECTION_BIT_1) | ENABLE(ADC_PRESCALER_SELECTION_BIT_2);
		break;
	}
	
	if (param->ADC_Enable_Interrupt == INIT)
	{
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_INTERRUPT_ENABLE);
	}
	
	if (param->ADC_Enable_Auto_Trigger == INIT)
	{
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_AUTO_TRIGGER_ENABLE);
	}
	
	switch(param->ADC_Auto_Trigger_Source)
	{
		case ANALOG_COMPARATOR :
		SPECIAL_FUNCTION_REG |= ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_0);
		break;
		
		case EXTERNAL_INTERRUPT_REQ :
		SPECIAL_FUNCTION_REG |= ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_1);
		break;
		
		case TIMER_0_COMPARE_MATCH :
		SPECIAL_FUNCTION_REG |= ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_0) | ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_1);
		break;
		
		case  TIMER_0_OVERFLOW :
		SPECIAL_FUNCTION_REG |= ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_2);
		break;
		
		case TIMER_1_COMPARE_MATCH:
		SPECIAL_FUNCTION_REG |= ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_0) | ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_2);
		break;
		
		case TIMER_1_OVERFLOW_MATCH :
		SPECIAL_FUNCTION_REG |= ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_1) | ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_2);
		break;
		
		case TIMER_1_CAPTURE_MODE :
		SPECIAL_FUNCTION_REG |= ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_0) | ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_1) | ENABLE(ADC_AUTO_TRIGGER_SOURCE_BIT_2);
		break;
	}
	ADC_STATUS = INIT;
}




uint16_t ADC_READ(uint8_t channel)
{
	uint16_t data=0;
	if (ADC_STATUS == INIT)
	{
		ADC_MULTIPLEXER_SELECTION_REG |= (ADC_MULTIPLEXER_SELECTION_REG&0xf8);
		switch(channel)
		{
			case CHANNEL_1 :
			ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(ANALOG_CHANNEL_SELECTION_BIT_0);
			break;
			
			case CHANNEL_2 :
			ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(ANALOG_CHANNEL_SELECTION_BIT_1);
			break;
			
			case CHANNEL_3 :
			ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(ANALOG_CHANNEL_SELECTION_BIT_0) | ENABLE(ANALOG_CHANNEL_SELECTION_BIT_1);
			break;
			
			case CHANNEL_4 :
			ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(ANALOG_CHANNEL_SELECTION_BIT_2);
			break;
			
			case CHANNEL_5 :
			ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(ANALOG_CHANNEL_SELECTION_BIT_0) | ENABLE(ANALOG_CHANNEL_SELECTION_BIT_2);
			break;
			
			case CHANNEL_6 :
			ADC_MULTIPLEXER_SELECTION_REG |= ENABLE(ANALOG_CHANNEL_SELECTION_BIT_1) | ENABLE(ANALOG_CHANNEL_SELECTION_BIT_2);
			break;
		}
		ADC_CONTROL_AND_STATUS_A_REG |= ENABLE(ADC_START_CONVERSION);
		_delay_us(10);
		while(!(ADC_CONTROL_AND_STATUS_A_REG&&(ENABLE(ADC_INTERRUPT_FLAG))));
		data = ADC_DATA_REG;
	}
	return data;
}